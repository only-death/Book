# 함수

> 코드 동작을 statement로 구현하고 코드 블로으로 감까서 하나의 실행 단위로 정의한 것

```js
//함수 정의
function add(x, y) {
  return x + y;
}

//함수 호출
add(2, 7);
```

- x, y 는 `매개변수(parameter)`로 함수 내부로 입력을 전달받는 변수
- 2, 7은 `인수(argument)`로 함수 호출로 넘겨주는 입력 값
- return x + y는 `반환문`
- return 뒤에 오는 x + y 는 `표현식`으로 그 값이 `반환값 (Return value)`이 된다.

**함수 정의(function definition)**를 통해 생성, **함수 호출(function call/ invoke)**로 실행 한다.<br>
함수는 객체 타입의 값이기 때문에 이름(식별자)를 붙일 수 있다.

<br>

### 함수 리터럴

함수도 숫자나 객체 처럼 함수 리터럴로 생성 가능.<br>
리터럴은 값을 생성하기 위한 표기법으로 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다. `(함수 = 객체)` <br>

**그러나 일반 객체와는 다르게 함수는 함수 고유의 프로퍼티를 갖고 호출을 할 수있다.**

```js
//함수 리터럴 = 함수 표현식
let sum = function add(x, y) {
  return x + y;
};
```

**구성요소**

- 함수 이름(=식별자): 이름이 있는 함수 (named function/ 기명 함수). 생략가능해 없다면 (무명 함수/ anonymous function)
- 매개변수 목록: 매개변수는 함수 호출시 인수의 순서대로 할당
- 함수 몸체: 함수 내 실행될 코드 블럭

### 함수 정의

함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환값 드을 지정하는것. <br>
정의된 함수는 JS엔진에 의해 평가되어 함수 객체가 된다.

#### 함수 정의 방식

1. **함수 선언문 (함수 이름 필수)**

```js

function add(x,y){
    reutrn x + y;
    }

```

함수 선언문은 `표현식이 아닌 문`이다. 그래서 변수에 할당할 수 없다.❌

```js
// 예제는 선언문이 변수에 할당 되는것 같지만 값으로 평가되는 문맥이면 함수 리터럴 (표현식)으로 해석.
let sum = function add(x, y) {
  return x + y;
};
```

**JS는 코드 문맥에 따라 표현식과 선언문으로 해석한다**

```js
// 함수 예제 1
function dog() {
  return console.log("dog");
}

dog(); // dog

// 함수 예제 2
(function cat() {
  return console.log("cat");
});

cat(); // ReferenceError: cat is no defined
```

**함수예제 1:** `dog함수`는 선언문으로 해석된다. <br>
선언문이라 함수 이름으로 호출 할수 있는것인가? ❌ <br>
선언문은 무조건 기명 함수이기 떄문에 식별자가 없어도 암묵적으로 함수 이름과 동일하게 식별자를 생성, 그 식별자는 함수가 저장되어있는 메모리 공간의 참조 값을 가진다. (객체기 때문에) <br>
따라서, 함수 이름으로 호출하는 것이 아닌 함수 객체를 가리키는 식별자로 호출하는것이 맞다. 👌

- 이처럼 암묵적으로 생성된 함수 식별자는 함수 객체로 초기화되어 선언문 전에 호출이 가능함 (함수 호이스팅).

```js
// JS 엔진이 표현식으로 변환해 함수 객체를 생성하는 격
var dog = function dog() {
  return console.log("dog");
};
```

**함수예제 2:** `cat함수`는 ()그룹 연산자로 감싸게 되면 값으로 평가해야하기 때문에 안에 함수는 선언문이 아니라 표현식이 된다. <br>
함수 리터럴의 함수 이름은 함수 내에서만 참조할 수 있는 식별자기 때문에 참조 오류가 뜸.

<br>

2. **함수 표현식 (함수 이름 생략 가능)**

```js
let sum = function (x, y) {
  return x + y;
};
```

함수 표현식은 `표현식인 문`이다. <br>

- 값의 성질을 가지는 객체를 일급 객체라 하여, JS의 함수는 일급 객체이다. <br>
- 함수 표현식을 쓸땐 무명 함수로 쓰는것이 일반적이다. <br>
- 함수 표현식은 변수에 할당되기떄문에 변수 호이스팅이 되어 undefined로 초기화됨. 함수는 할당문이 실행될때 (run-time)일떄 평가되어 함수 객체로 생성됨.
- 그리고 undefined던 변수는 함수를 참조하는 값이 들어가게 됨.

<br>

3. **Function 생성자 함수**

```js
let add = new Function("x", "y", "reutrn x + y");
```

<br>

4. **화살표함수**

```js
let add = (x, y) => x + y;
```

화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고. prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

<br>

### 함수 호출

**매개변수**

- 함수 내 사용되는 변수
- 함수 스코프
- 함수가 호출될떄 암묵적으로 매개변수 생성 -> undefined로 초기화 -> 인수 할당

**인수**

- 함수 호출시 매개변수로 전달 되는 값
- 값으로 평가될수 있는 표현식이어야됨

인수와 매개변수 갯수가 같을 필요 없고 오류도 뱉지 않음. <br>
모자란 인수의 매개변수는 'undefined'로 됨 <br>
초과 된 것음 암묵 적으로 arguments 객체 프로퍼티에 보관, 실행 될때는 무시함 <br>
인수순서 대로 매개 변수에 할당되어 순서가 중요함 <br>
객체로 인수를 넘겨주면 키 값으로 매개변수를 지정할 수 있어 순서 상관 없게 됨. <br>

**반환문**

함수는 `return` 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환.

- 반환문은 함수의 실행을 중단 그 함수 블럭에서 나옴
- return 키워드 뒤에 오는 표현식을 평가해 반환

```js
function add(x, y) {
  return x + y;
}
```

반환문 : `return x + y;` <br>
반환값으로 사용할 표현식 : `x + y`; <br>
표현식을 지정 안하면 : `undefined` <br>

<br>

### 참조에 의한 전달과 외부 상태의 변경

객체를 매개 변수로 줄때 참조값이 전달 되어 원본 객체를 훼손 할 수 있음.
이를 막기 위해 방어적 복사(defensive copy)로 원본 객체를 deep copy해서 사용할 수 있음.

외부 상태를 변경하지도, 의존 하지도 않는 함수를 `순수 함수`라 함.
