- [04 변수](#04-변수)
- [05 표현식과 문](#05-표현식과-문)

---

# 04 변수

### 용어 정리

#### 메모리 : 데이터를 저장할 수 있는 메모리 셀의 집합체

#### 메모리 주소 : 메모리 공간의 위치치

#### 변수 : 하나의 값을 저장하기 위해해 확보한 메모리 공간 자체 / 그 메모리 공간을 식별하기 위해 붙인 이름

#### 변수이름(변수명) : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름

#### 할당 : 변수에 값을 저장하는 것

#### 참조 : 변수에 저장된 값을 읽어들이는 것

#### 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름

#### 변수 선언 : 변수를 생성하는 것

#### 키워드 : 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어

#### 실행 컨텍스트 : 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 실행 결과를 시루제로 관리하는 영역

#### 초기화 : 변수가 선언된 이후 최초로 값을 할당하는 것

#### 쓰레기 값 : 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값

#### 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

#### 재할당 : 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

#### 가비지 콜렉터 : 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능

#### 예약어 : 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어

#### 네이밍 컨벤션 : 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙

---

컴퓨터는 CPU를 사용해 연산하고, [메모리](#메모리--데이터를-저장할-수-있는-메모리-셀의-집합체)를 사용해 데이터를 기억한다. 이때 컴퓨터는 메모리 셀의 크기(1바이트)단위로 데이터를 저장하거나 읽어들인다. 각 셀은 고유의 메모리 주소를 갖는다.

메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있으므로 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

프로그래밍 언어는 값을 메모리에 저장하고, 재사용하기 위해 [변수](#변수--하나의-값을-저장하기-위해해-확보한-메모리-공간-자체--그-메모리-공간을-식별하기-위해-붙인-이름)라는 메커니즘을 제공한다.

`변수 == 값의 위치를 가리키는 상징적인 이름`

[변수 이름](#변수이름변수명--메모리-공간에-저장된-값을-식별할-수-있는-고유한-이름)을 사용해 [참조](#참조--변수에-저장된-값을-읽어들이는-것)를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

변수명은 [식별자](#식별자--어떤-값을-구별해서-식별할-수-있는-고유한-이름)(변수, 함수, 클래스 등의 이름도 포함된다)라고도 한다. 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해내야 하기 때문에 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)한다.
즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 매핑 정보도 메모리에 저장되어야 한다.

```
식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다.
=> 식별자 == 메모리 주소에 붙인 이름
```

메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자이다. 식별자는 [네이밍 규칙](#식별자-네이밍-규칙)을 준수해야 하며 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

※ 식별자는 실행 컨텍스트에 등록되며,자바스크립트 엔진은 [실행 컨텍스트](#실행-컨텍스트--자바스크립트-엔진이-소스코드를-평가하고-실행하기-위해-필요한-환경을-제공하고-실행-결과를-시루제로-관리하는-영역)를 통해 식별자와 스코프를 관리한다.

[변수 선언](#변수-선언--변수를-생성하는-것)을 통해 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비한다. 이렇게 확보된 공간은 해제되기 전까지 공간을 사용할 수 없도록 보호되어 안전하게 사용 가능하다.

변수를 선언할 때는 var, let, const [키워드](#키워드--코드를-해석하고-실행하는-자바스크립트-엔진이-수행할-동작을-규정한-일종의-명령어)를 사용한다.

```js
var score; //변수 score 선언
```

위 선언문 이후 변수에 값을 [할당](#할당--변수에-값을-저장하는-것)하지 않아 undefined라는 값이 암묵적으로 할당되어 [초기화](#초기화--변수가-선언된-이후-최초로-값을-할당하는-것)된다.

![image](https://github.com/user-attachments/assets/2e74b243-223a-4ee0-8660-4e7c5152e5d0)

`자바스크립트 엔진의 변수 선언 과정`

- 선언 단계 변수 이름을 등록 - 자바스크립트 엔진에 변수의 존재를 알림

- 초기화 단계 값을 저장하기 위해 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 변수 값을 참조하면 [쓰레기 값](#쓰레기-값--확보된-메모리-공간에는-이전에-다른-애플리케이션이-사용했던-값)이 나올 수 있다. var 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험에서 안전한다.

※선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.

변수 선언은 런타임이 아닌 그 이전 단계에서 먼저 실행된다.

```js
console.log(score); // undefined 출력
var score; //변수 score 선언
```

자바스크립트 엔진은 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 아 과정에서 모든 선언문을 소스코드에서 찾아내 먼저 실행한다.

∴ 변수 선언이 어디에 위치하는 지와 상관없이 어디서든지 변수를 참조할 수 있다.

=> 이러한 특징을 [변수 호이스팅](#변수-호이스팅--변수-선언문이-코드의-선두로-끌어-올려진-것처럼-동작하는-자바스크립트-고유의-특징)이라 한다.

변수에 값을 할당할 때는 할당 연산자(=)를 사용한다. - 우변의 값을 좌변의 변수에 할당

```js
var score;
score = 80;
```

```js
var score = 80;
```

위 두개의 코드는 동일하게 동작한다. 하나의 문으로 단축 표현해도 변수 선언은 런타임 이전에 먼저 실행되고 값의 할당은 런타임에 순차적으로 실행된다.

![image](https://github.com/user-attachments/assets/a96296e7-1871-4acb-892b-2f1c194aaf71)

변수에 undefined가 할당되어 초기화되는 것은 변함이 없다. 변수에 값을 할당할 때는 undefined가 저장되어 있던 공간을 지우는 것이 아닌 새오운 메모리 공간을 확보하고 그곳에 값을 저장한다.

```js
예제
console.log(score);

var score;
score = 80;

console.log(score);

=> undefined
   80
   변수 score가 선언되고 위에서부터 순차적으로 코드가 선언된다.
```

var 키워드로 선언한 변수는 값을 [재할당](#재할당--이미-값이-할당되어-있는-변수에-새로운-값을-또다시-할당하는-것)할 수 있다. (undefined가 처음 할당되기 때문에 처음 값을 할당하는 것도 재할당이다.)

재할당 역시 원래의 메모리 공간에 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 공간에 값을 저장한다.

재할당 전에 사용된 메모리 공간은 어느 식별자와도 연결되어 있지 않으면 불필요한 값으로 여기고 [가비지 콜렉터](#가비지-콜렉터--애플리케이션이-할당한-메모리-공간을-주기적으로-검사하여-더-이상-사용되지-않는-메모리를-해제하는-기능)에 의해 메모리에서 자동 해제된다.

---

#### 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있다.
- 식별자는 특수문자를 제외한 문자, 언더스코어, 달러 기호로 시작해야 한다.
- [예약어](#예약어--프로그래밍-언어에서-사용되고-있거나-사용될-예정인-단어)는 식별자로 사용할 수 없다.

---

---

# 05 표현식과 문
### 용어 정리

#### 값 : 식(표현식)이 평가되어 생성된 결과

#### 평가 : 식을 해석해서 값을 생성하거나 참조하는 것

#### 리터럴 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

#### 표현식 : 값으로 평가될 수 있는 문

#### 문 : 프로그램을 구성하는 기본 단위이자 최소 실행 단위

#### 토큰 : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

---
```js
10 + 20;
```
=> 식은 [평가](#평가--식을-해석해서-값을-생성하거나-참조하는-것)되어 [값](#값--식표현식이-평가되어-생성된-결과) 30을 생성한다.

```js
var sum = 10 + 20;
```
=> sum 변수에 할당되는 것은 10 +20 이 아닌 10+20이 평가된 결과 값 30이다.
=> 10 + 20은 할당 이전에 평가되어 값을 생성한다. 

```js
3
```
=> 3은 숫자 [리터럴](#리터럴--사람이-이해할-수-있는-문자-또는-약속된-기호를-사용해-값을-생성하는-표기법)이다.

=> 아라비아 숫자를 사용해 숫자 리터럴 3을 기술하면 자바스크립트 엔진은 이를 평가에 숫자 값 3을 생성한다. 

자바스크립트 엔진은 런타임에 [리터럴](#리터럴--사람이-이해할-수-있는-문자-또는-약속된-기호를-사용해-값을-생성하는-표기법)을 평가해 값을 생성한다. 

![image](https://github.com/user-attachments/assets/553a0d65-1d09-4273-b61f-a1a04ca61619)

리터럴은 값으로 평가되므로 [표현식](#표현식--값으로-평가될-수-있는-문)이다. 

표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. 

```js
var score = 100; 
```
=> 리터럴 100은 평가되어 값을 생성하므로 리터럴은 그 자체로 표현식이다.
```js
var score = 50 + 50;
```
=> 50 +50 도 평가되어 숫자 값을 생성하므로 표현식이다. 
```js
score;
```
=> 식별자 참조는 값을 생성하진 않지만 값으로 평가되므로 표현식이다. 

표현식은 리터럴, 식별자, 연산자, 함수호출 등의 조합으로 이뤄질 수 있다. 

∴ 즉, 값으로 평가될 수 있는 문은 모두 표현식이다. 

표현식은 값으로 평가된다(값으로 사용할 수 있음). 즉, 문법적으로 값이 위치할 수 있는 자리에는 표현식이 위치할 수 맀다. 

표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다. 

```js
var x = 1 + 2;
x + 3;
```

자바스크트 엔진의 입장으로 코드를 읽고 예측하기 위해선 [문](#문--프로그램을-구성하는-기본-단위이자-최소-실행-단위)과 [표현식](#표현식--값으로-평가될-수-있는-문)을 구별하고 해석할 수 있어야 한다. 

문의 집함으로 이뤄진 것이 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문은 여러 [토큰](#토큰--문법적인-의미를-가지며-문법적으로-더-이상-나눌-수-없는-코드의-기본-요소)으로 구성되며 명령문이라고도 불린다

ex) 키워드 ,식별자, 연산자, 리터럴, [세미콜론](#세미콜론은-문의-종료를-나타낸다-자바스크립트-엔진은-세미콜론으로-문이-종료한-위치를-파악하고-순차적으로-하나씩-문을-실행한다-하지만-자바스크입트-엔진은-세미콜론-자동-삽입-기능이-암묵적으로-수행되어-세미콜론은-생략이-가능하다), 마침표 등이 있다. 

문은 선언문, 할당문, 조건문, 반복문 등으로 구성되어 있다. 

![image](https://github.com/user-attachments/assets/33b75bd3-5332-42f4-8093-1855a1209770)

문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 

변수에 할당하는 것을 통해 두 개를 구별할 수 있다. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있고 표현식이 아닌 문은 변수에 할당하면 에러가 발생한다. 

![image](https://github.com/user-attachments/assets/3ef13f54-65d4-41f5-ac49-516e53175b1c)


---------
#### 세미콜론은 문의 종료를 나타낸다. 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 하지만 자바스크입트 엔진은 세미콜론 자동 삽입 기능이 암묵적으로 수행되어 세미콜론은 생략이 가능하다. 
