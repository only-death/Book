# 04. 변수

## 01. 변수란 무엇인가? 왜 필요한가?

변수: 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념

1. 변수란 무엇인가?

```
10(literal) +(연산자: operator) 20(literal) (표현식: expression) = (평가: evaluation)
(해석: parsing)
```

cpu: 연산
<br/>
메모리: 데이터 기억 -> 메모리 셀의 집합
<br/>
피연산자(operand): 연산자의 좌변과 우변의 숫자 값
<br/>
참조: 변수의 값을 읽어들이는 것

### 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.(값의 위치를 가리키는 상징적인 이름)

2. 왜 필요한가?

- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 일으킬 가능성이 크다
- 값이 저장될 메모리 주소는 코드가 실행될 때마다 값이 저장될 메모리 주소는 변경된다
- 코드가 실행되기 전에는 값이 저장된 메모리 주소도 알 수 없으며, 알려 주지도 않는다. 메모리 주소를 통해 값에 직접 접근하는 것은 올바른 시도가 아니다.
- 변수 이름을 통해 변수에 저장된 값을 명확하게 할 수 있다 따라서 좋은 이름, 즉 변수에 저장된 값의 의미를 파악할 수 있는 변수 이름은 가독성을 높이는 부수적인 효과도 있다 이는 협업과 품질 향상에 도움을 준다

## 02. 식별자: 어떤 값을 식별할 수 있는 이름, 값이 아닌 메모리 주소를 기억

(변수 이름 === 식별자)

## 03. 변수 선언

값을 저장하기 위해 **메모리값을 확보**하고 변수 이름과 확보된 메모리 공간의 **주소를 연결해서 값을 저장**할 수 있게 **준비**하는 것

- 선언단계: 변수 선언은 메모리 공간을 **"예약"** 하는 단계
- 초기화단계: 초기화는 그 메모리 공간에 **"값을 할당"** 하는 단계

## 04. 변수 선언의 실행 시점과 변수 호이스팅

- var:
  - 호이스팅(Hoisting) 시 변수 선언이 끌어올려지지만 초기화는 선언문에서 이루어집니다.
  - 선언은 호이스팅되어 상단으로 이동하지만, **값을 할당하기 전까지는 undefined**로 접근됩니다.

그래서 아래 코드에서는 score 변수에 값을 할당하기 전까지 undefined가 출력됩니다.

```
console.log(score); // undefined
var score; // 변수 선언문
```

- let, undefined
  - let과 const는 호이스팅이 발생하지만, 선언된 변수는 초기화가 이루어지기 전까지 접근할 수 없습니다.
  - 이 구간을 **일시적 사각지대(Temporal Dead Zone, TDZ)** 라고 부릅니다.

따라서 let과 const로 선언한 변수에 대한 참조는 초기화가 이루어지기 전까지는 참조 오류(ReferenceError)가 발생합니다.

```
console.log(score); // ReferenceError: Cannot access 'score' before initialization

let score; // 변수 선언문
```

## 05. 값의 할당

- 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```
console.log(score); // undefined
var score = 80; // 변수 선언, 값 할당
console.log(score); // 80
```

- 주의점: 변수에 값을 할당할 때 undefined의 값을 지우는 게 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다.

```
console.log(score); // undefined, 변수 할당 x

score = 80; // 80 할당
var score; // 변수 선언(호이스팅)

console.log(score); // 80
```

## 06. 값의 재할당

```
let x = 10;
x = 20; // 재할당 가능

const y = 30;
y = 40; // 오류 발생: TypeError: Assignment to constant variable.

```

변수 = 재할당 가능
</br>
상수 = 재할당 불가능
</br>
가비지 콜렉터 = 아무도 사용하지 않는 값을 해제시킴(언제 해제되는지는 예측 불가능)

## 07. 식별자 네이밍 규칙

변수나 함수 이름에는 카멜케이스(fistTime), 생산자 함수나 클래스에는 파스칼케이스(FirstTime) 사용
</br></br>
스네이크케이스: (first_time)
</br>
헝가리언케이스
</br></br>

# 05. 표현식과 문

## 01. 값

: 표현식이 평가되어 생성된 결과

```
var score = 10 + 20 // 값 = 30
```

## 02. 리터럴

: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
</br>
자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

## 03. 표현식

: 값으로 평가될 수 있는 문

```
var score = 100 // 100 = 리터럴 = 값 = 표현식
```

## 04. 문

문: 프로그램을 구성하는 기본 단위이자 최소 실행단위
</br>
토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

```
(토큰) (토큰) (토큰) (토큰) (토큰)
 var  score   =    100    ;  // => 문
```

(ex) 변수 선언문, 할당문, 함수 선언문, 조건문, 반복문

## 05. 세미콜론과 세미콜론 자동 삽입 기능

```
function foo() {
    return  // ASI => return ;
    {
        name: 'Alice'
    };      //  개발자 => return {};
}
console.log(foo()); // undefined


var bar  = function(){}
(function() {})();

// ASI => var bar = function() {} (function() {})();
// 개발자 => var bar = function() {}; (function() {})();

```

: 세미콜론은 문의 종료를 나타내고, 세미콜론의 자동 삽입 기능은 개발자의 예측과 일치하지 않는 경우가 종종 있다.

## 06. 표현식의 문과 표현식이 아닌 문

표현식익 문: 값으로 평가 가능

```
var x; // 변수 선언문은 표현식 x

x = 100; // 할당식은 그 자체가 표현식이지만 완전한 문이기도 함. 즉, 할당문은 표현식.
```

</br>
표현식이 아닌 문: 값으로 평가 불가

```
var foo = var x;
```

</br>

**구분하는 방법**: 변수에 할당되면 표현식, 안 되면 표현식이 아닌 문
</br></br>
완료값: 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 undefined를 출력한다.
