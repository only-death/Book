# 12. 함수

## 7. 다양한 함수의 형태

### 1. 즉시 실행 함수

: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것, 즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없다.

```js
// 즉시 실행 함수도 일반 함수처럼 인수를 전달할 수 있다
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
})();

console.log(res);

// 즉시 실행 함수도 일반 함수처럼 인수를 전달할 수 있다
res = (function (a, b) {
  return a * b;
})(3, 5);

console.log(res);
```

: 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있다.

### 2. 재귀 함수

: 함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 함수는 재귀 호출을 수행하는 함수를 말한다.

```js
var factorial = function foo(n) {
  if (n <= 1) return 1; // n <= 1이 되면 탈출한다.
  return n * factorial(n - 1);
};

console.log(factorial(5)); // 5! = 120
```

: 탈출 조건을 무조건 만들어야 한다. 재귀함수는 반복문을 사용하는 것보다 재귀 함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.

### 3. 중첩 함수

: 함수 내부에 정의된 함수를 중첩합수 또는 내부함수라 한다. 그리고 중첩함수를 포함하는 함수는 외부 함수라 부른다.

```js
function outer() {
  var x = 1;

  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }

  inner(); // 함수 내부에서만 호출할 수 있다.
}

outer();
```

: 호이스팅으로 인해 혼란이 발생할 수 있으므로 if문이나 for 문 등의 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다.(스코프, 클로저 참고)

### 4. 콜백 함수

: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.(27.9절 "배열 고차 함수" 참고)

```js
// 고차 함수: filterNumbers
function filterNumbers(arr, callback) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (callback(arr[i])) {
      // 콜백 함수에 의해 필터링됨
      result.push(arr[i]);
    }
  }
  return result;
}

// 콜백 함수: isEven
function isEven(num) {
  return num % 2 === 0;
}

const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = filterNumbers(numbers, isEven); // filterNumbers에서 isEven을 콜백으로 사용
console.log(evenNumbers); // [2, 4, 6]
```

:고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.

### 5. 순수 함수와 비순수 함수

- 순수 함수: 동일한 인수가 전다되면 동일한 값을 반환하는 함수

```js
function multiply(a, b) {
  return a * b; // 동일한 입력에 대해 항상 동일한 출력
}

console.log(multiply(2, 3)); // 6
console.log(multiply(2, 3)); // 6
```

- 비순수 함수: 외부 상태에 따라 반환값이 달라지는 함수

```js
let result = 10; // 외부 상태

function addToResult(value) {
  result += value; // 외부 상태 변경
  return result;
}

console.log(addToResult(5)); // 15
console.log(addToResult(5)); // 20, 외부 상태(result)가 변경되었기 때문에 출력이 달라짐
```

: 함수가 외부 상태를 변경하면 상태 추적이 어려워지므로 권장하지 않음

# 13. 스코프

## 1. 스코프란?

: 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참도할 수 있는 유효 범위가 결정된다. 이를 스코프라고 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.

- 식별자 결정

```js
// 전역 변수
var x = 'global';

// 지역 변수
function foo() {
  var x = 'local';
  console.log(x); // 'local'
}

foo();

console.log(x); // 'global'
```

: 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에서 같은 이름이 식별자를 사용할 수 있다.

## 2. 스코프의 종류

### 1. 전역과 전역 스코프

- 전역: 코드의 가장 바깥 영역
  - 전역 변수는 어디서든 참조할 수 있다
- 지역: 함수 내부 몸체

### 2. 지역과 지역 스코프

- 지역 변수는 자신의 지역 스코프와 하위 스코프에서 유효하다.

## 3. 스코프 체인

: inner -> outer -> 전역 스코프처럼 스코프가 계층적으로 연결된 것

- 함수의 중첩: 팜수 몸체 내부에서 함수가 정의된 것
- 중첩 함수: 함수 몸체 내부에서 정의한 함수
- 외부 함수: 중첩 합수를 포함하는 함수

-> 함수는 중첩될 수 있으므로 지역 스코프도 중첩될 수 있다. **스코프가 함수 중첩에 의해 계층적 구조를 갖는다**라는 것을 의미한다.

- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.(마치 상속과도 같은 개념이다.)

### 1. 스코프 체인에 의한 변수 검색

- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

```js
function foo() {
  console.log('aa');
}

function bar() {
  function foo() {
    console.log('bb');
  }
  foo();
}

bar(); // 'bb'
```

## 4. 함수 레벨 스코프

: 지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다.

- 함수 스코프: var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
- 블록 레벨 스코프: 함수 몸체만이 아닌 모든 코드 블록(if, for, while, tye/catch 등)이 지역 스코프를 만든다.

```js
var i = 10;

// 전역변수 재할당
for (var i = 0; i < 5; i++) {
  console.log(i); // 1 2 3 4
}

console.log(i); // 5 전역변수 재할당
------------------------------------------------
let i = 10;

// 전역변수 재할당 x
for (let i = 0; i < 5; i++) {
  console.log(i); // 1 2 3 4
}

console.log(i); // 10
```

## 4. 렉시컬 스코프

: 함수가 호출된 위치는 상관없이 함수의 상위 스코프는 언제나 자신이 정의한 스코프다.

1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.

- 동적 스코프: 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 함

2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.

- **렉시컬스코프, 정적 스코프: 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정됨(자바스크립트)**

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```
