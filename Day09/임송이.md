# 12.7장 다양한 함수의 형태

### 즉시 실행 함수 (IIFE, Immediately Invoked Function Expression)

함수 정의와 동시에 실행되는 함수. 재실행 ❌

```js
// 익명 함수 쓰는 것이 일반적
// () 그룹 연산자로 감쌀때
(function () {
  let a = 3;
  let b = 5;
  return a * b;
})();

// IIFE 다른 방식
// 그룹 연산자 외에 !나 + 연사자로 함수 리터럴을 평가해 함수 객체를 생성
(function () {
  // ...
})();

(function () {
  // ...
})();

!(function () {
  // ...
})();

+(function () {
  // ...
})();
```

### 재귀 함수

- 함수가 자기 자신을 호출 하는 것을 재귀 호출 (Recursive Call)이라 한다.
- 재귀 함수(Recursive function)는 자기 자신을 호출 하는 행위, 재귀 호출을 수행 하는 함수이다.
- 함수 내에서 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 된다. (안그러면 무한이 반복).

```js
function countdown(n) {
  if (n < 0) return; // 탈출 조건
  console.log(n);

  countdown(n - 1); // 재귀 호출
}

countdown(10);
```

### 중첩 함수

- `중첩함수(nested function):` 또는 내부함수 (inner function)은 함수 내부에 정의 된 함수.
- `외부 함수(outer function`: 중첩 함수를 가지고 있는 부모 함수.
- 일반적으로 중첩함수는 자신을 포함 외부 함수를 돕는 헬퍼 함수(helper function)의 역할을 한다.
- 중첩 함수는 외부함수 내에서만 호출 가능하고 외부함수의 변수를 참조 할 수 있다.

```js
function outerFunction(name) {
  // 외부 함수

  console.log(`Hello, ${name}!`);

  function innerFunction(greeting) {
    // 내부 함수
    console.log(`${greeting}, ${name}!`);
  }

  innerFunction("Welcome"); // 내부 함수 호출
}

outerFunction("Alice");
```

### 콜백 함수

- `콜백함수 (callback function):` 함수의 매개 변수를 통해 다른 함수의 내부로 전달되는 함수.
- `고차함수 (high=ordered function:` 매개 변수를 통해 함수 외부에서 콜백함수를 전달 받는 함수.

콜백함수는 고차함수에 의해 호출.<br>
고차함수는 필요에 따라 콜백함수에 인수를 전달. <br>

**고차 함수가 콜백함수 호출시기를 정하기 때문에 인수로 넘길때 콜백함수 자체를 전달해야됨 (호출❌)**

```js
// 재사용이 필요없는 콜백 함수라면 무명으로 바로 고차함수 인수로 전달.

function sayHello(callback) {
  callback("Hello, World!");
}

// 익명 함수로 콜백 전달
sayHello(function (message) {
  console.log(message);
});
```

**익명 함수 리터럴로 보낼시 고차함수가 호출 될때 마다 콜백 함수가 생성됨**

<br>

### 순수 함수와 비순수 함수

- `순수함수(pure function):` 외부상태에 의존하지고 변경하지도 않는 함수. (데이터 안정성을 높임).
- `비순수 함수 (impure function`: 외부상태에 의존하거나 변경하는 함수. 부수효과 생성 (side-effect).

#### 순수함수

- 동일한 인수가 전달되면 언제나 동일한 값을 반환.
- 최소 1이상의 인수를 전달 받음. (0개시 상수나 다름 없음).
- 오직 매개변수를 통해 함수 내부에 전달된 인수에만 의존해 값을 생성.
- 외부상태에 의존하지 않더라도 내부상태가 호출될때마다 값이 변하면 순순 함수가 ❌ (예. 현재시간)
- 인수의 불변성 유지 (인수를 변경하지 않음)
  _외부상태에는 전역변수, 서버데이터, 파일, Console, DOM등이 있다_.

```js
function add(a, b) {
  return a + b; // 동일한 입력이면 항상 동일한 출력
}

console.log(add(2, 3)); // 5
console.log(add(2, 3)); // 5
```

#### 비순수 함수

- 외부 상태에 의존하거나 변경해 부수효과를 생성.
- 함수 내부에서 직접 외부상태를 참조하지 않더라도 매개변수를 통해 객체(mutable value)를 전달 받으면 비순수 함수.

```js
let num = 10;

function addToNum(a) {
  num += a; // 외부 상태를 변경함 return num;
}

console.log(addToNum(5)); // 15 (num이 변경됨)
console.log(addToNum(5)); // 20 (num이 다시 변경됨)
```

**함수형 프로그래밍에서는 순수함수와 보조함수의 조합을 통해 부수효과를 줄여 오류를 방지하고 프로그램의 안정성을 높히는것을 지향한다.**

<br>

# 13장 스코프

### 스코프(scope)란?

> 식별자가 유효한 범위

모든 식별자(변수 이름, 함수이름, 클래스 이름등)는 자신이 `선언된 위치`에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.

JS엔진은 스코프를 통해 어떤 변수를 참조해야 할지 결정하는데 이를 `식별자 결정(identifier resolution)`이라고 한다. 따라서 스코프란 JS엔진 식별자를 검색할때 사용하는 규칙이라 할 수 있다.

JS엔진은 코드를 실행할때 코드의 문맥 (context)를 고려한다.
코드의 문맥은 렉시컬환경 (Lexical environment)으로 이뤄지면 이걸 구현한것이 `실행 컨텍스트(execution context)` 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.

<br>

### 스코프의 종류

- `전역 스코프(global scope):` 전역적으로 유효한 범위. 전역 변수는 어디서든 참조 가능.
- `지역 스코프 (local scope)`: 본인 코드블럭 몸체 내 (하위 스코프 포함)에서 유효한 범위. 지역범수는 그 안에서만 유효
  - 함수 스코프(function scope): 함수 내부에서만 유효
  - 블록 레벨 스코프 (block scope): {}안에서만 유효한 범위 (if, while, for, try/catch 등)

<br>

### 스코프 체인

스코프 체인은 계층적 구조를 가진다.
제일 내부에서 부터 외부로 `단방향` 스코프 체인이 일어난다.
JS엔진은 이 스코프 체인을 참고해 식별자를 검색하는데 여기서 `단방향`으로 이뤄지기 떄문에
하위 스코프에서는 상위 스코프의 변수를 참조가능 하지만 상위에서는 하위 스코프 내 변수를 참조하지 못한다.

이 스코프 체인은 물리적으로 존재, JS는 렉시컬 환경을 실제로 생성한다.
렉시컬 환경은 아래 그림처럼 그 상위 스코프(또 다른 렉시컬 환경)의 참조를 외부환경 참조 (Outer Lexical Environment Reference)에 기록한다.
이런식으로 체이닝을 해 위치를 기억할 수 있음.

![[Screenshot 2025-01-21 at 12.34.47 PM.png]]

<br>

### 함수레벨 스코프

코드 블록이 아닌 함수에 의해서만 생긴 지역 스코프

`var` 키워드로 선언된 변수는 오로지 `함수 레벨 스코프`만을 지역 스코프로 인정한다.
다시말해 다른 {} 블록 레벨에서 정의된 var는 전역변수나 다름없는 것이다.

<br>

### 렉시컬 스코프

상위 스코프를 정의하는 방식 2가지

1. `동적 스코프(dynamic scope):` 함수를 `호출한 위치`에 따라 함수의 상위 스코프 결정.
2. `렉시컬 스코프 (lexical scope):` 또는 정적 스코프(static scope)는 함수를 `정의한 위치`에 따라 상위 스코프를 결정.

자바스크립트는 렉시컬 스코프를 따르므로 함수가 정의된 위치 기반으로 상위 스코프를 결정한다.
렉시컬 스코프이기 때문에 계층적인 구조를 가질 수 밖에 없음.
