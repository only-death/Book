# this

많은 사람들이 자바스크립트에서 혼란스럽다고 생각하는 부분 중 하나로 `this`를 고른다.

다른 객체지향 언어와는 달리 **javaScript에서의 `this`는 어디서든 사용이 가능하다!**  
`this`는 상황에 따라 바라보는 대상이 달라지는데, 이로 인해 다들 파악하기 힘들어하거나 대상을 헷갈리는 경우도 많다.

함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 `this`는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다. 그러니 상황별로 `this`가 어떻게 달라지는지, 왜 그러는지, 대상을 헷갈렸을 경우 효과적으로 추적하는 방법을 살펴보자!

## 상황에 따라 달라지는 this

**❗ `this`는 함수를 호출할 때 결정된다.**

> 기본적으로 `this`는 실행 컨텍스트가 생성될 때 함께 결정되지만 실행 컨텍스트는 함수를 호출할 때 생성된다.

결론적으로는 함수를 어떤 방식으로 호출하느냐가 `this`의 값을 정하는 것이다.  
그럼 상황별 `this`가 어떤 값을 보게 되는지, 왜 그런지를 보자!

### 전역 공간에서의 `this`

전역 공간에서 `this` -> 전역 객체

전역 공간에서는 전역 컨텍스트를 생성하는 주체가 전역객체이기 때문이다.

> 자바스크립트 런타임 환경에 따라 다른 이름을 갖는 전역 객체  
> 브라우저 환경에서는 `window`, Node.js 환경에서는 `global`

![](https://velog.velcdn.com/images/pmj9498/post/1687e74d-ebc1-4bc6-ae7a-6a307269c285/image.png)

> 참고)  
> 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.  
> 삭제를 제외하고는 대부분 window의 프로퍼티에 직접 할당하더라도 var로 선언한 것과 똑같이 동작한다.  
> ![](https://velog.velcdn.com/images/pmj9498/post/69de6d91-a838-4540-ba90-36fb57ba6de5/image.png)
> 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되지만 전역변수로 선언한 경우에는 삭제가 되지않는데, 이는 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이라고 생각하면 된다.

### 메서드로서 호출할 때 그 메서드 내부에서의 `this`

함수를 실행하는 가장 일방적인 방법 두 가지는 함수로서 호출하는 경우와 메서드로서 호출하는 경우이다.

프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치라는 공통점이 있지만, 함수는 그 자체로 독립적인 기능을 수행하는 반면 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다는 차이점이 있다.

> 함수로서 호출 and 메서드로서 호출 구분하는 방법  
> 함수 앞에 **점(.)**이 있는지 여부만으로 간단하게 구분 가능  
> 점이 없으면 '함수로서 호출' 있으면 '메서드로서 호출'(대괄호 표기법도 메서드 호출)

![](https://velog.velcdn.com/images/pmj9498/post/1a3684e9-c53d-4172-9d52-f65dbf1afc67/image.png)

- 메서드로서 함수를 호출하는 경우 : `this` -> **함수명(프로퍼티명) 앞의 객체(점 표기법의 경우 마지막 점 앞에 명시된 객체)**

### 함수로서 호출할 때 그 함수 내부에서의 `this`

- 보통 전역객체를 참조한다.

**<우회법>**  
![](https://velog.velcdn.com/images/pmj9498/post/59187365-a2e8-4dfd-8f6d-8f1605a415b6/image.png)  
보통 많이 쓰이는 변수명 self에 상위 스코프의 `this`를 저장해서 내부함수에서 활용한다.

#### this를 바인딩하지 않는 함수

![](https://velog.velcdn.com/images/pmj9498/post/b9584231-fc42-4abd-973c-7ee3a92b91ff/image.png)

ES6에서 `this`가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수(arrow function)을 도입하여 상위 스코프의 `this`를 그대로 활용할 수 있다.

> ❌ ES5에서 화살표 함수를 사용할 수 없음

### 콜백 함수 호출 시 그 함수 내부에서의 `this`

콜백 함수도 함수이기 때문에 기본적으로 `this`가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 `this`가 될 대상을 지정한 경우에는 그 대상을 참조함!

예시)  
![](https://velog.velcdn.com/images/pmj9498/post/5601c862-bae0-4130-9838-ca8d0e56503e/image.png)

- (1), (2)는 `this`를 따로 지정하지 않아 전역객체 참조, (3)은 `addEventListener` 메서드명의 점(.) 앞 부분이 `this`가 되는 것

### 생성자 함수 내부에서의 `this`

프로그래밍적으로 '생성자'는 구체적인 인스턴스를 만들기 위한 일종의 틀이다. 자바스크립트는 함수에 생성자로서의 역할을 함께 부여했으며, `new` 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다.  
이 때, 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 `this`는 곧 새로 만들 구체적인 인스턴스 자신이 된다!

![](https://velog.velcdn.com/images/pmj9498/post/50ee5a15-627b-4c59-90aa-71bf4f26e19b/image.png)

여기서 `this`는 `new` 명령어와 함께 `Cat` 함수를 호출해서 `choco`, `nabi`에 각각 할당하여 출력한 것을 보면 각각 Cat 클래스의 인스턴스 객체가 출력됐다.
이렇게 6번째 줄에서 실행한 생성자 함수 내부에서의 `this`는 `choco` 인스턴스, 7번째 줄에서의 `this`는 `nabi` 인스턴스를 가리키는 것을 알 수 있다.
