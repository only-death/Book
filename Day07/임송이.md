# 11장 원시 값과 객체의 비교

## 원시값

> 변경 불가능 한 값 (immutable value)

#### 불변성

`변수:` 하나의 값을 저장하기 위해 확보한 메모리 공간, 또는 그 메모리 공간을 식별하기 위한 이름
(데이터 값이 저장되어 있는 메모리 주소를 가리킴)
`값:` 변수에 저장된 데이터로 표현식으로 평가 되어 생성된 결과

**변경이 불가능** 하다는 것은 (read-only)라는 뜻이므로 변수에 값을 재할당 하더라고 전에 저장되어 있는 메모리 공간이 사라지지 않는다. 변수는 새롭게 할당된 원시값 자체를 다른 메모리 주소에 만들어 새 값을 가진 메모리 주소를 가리킨다.

_따라서 원시값을 할당한 변수는 재할당 이외에 변수의 값을 변경할 수 있는 방법이 없다._

이 불변성 덕에 타입별 확보할 메모리 크기가 미리 정해져 있다.
<br>
(자바스크립트에서는 string도 원시타입)

- `문자열 = 2byte`
- `숫자 = 8byte`

- **문자 캐릭터 하나당 2byte이기 때문에 '1'은 2byte '10000'은 10byte 크기를 가짐**
- **숫자는 1이든 100000이든 8byte를 가진다**

문자열은 유사배열(array-like object)으로 length 프로퍼티를 가지고 배열의 인덱스로 각 문자에 접근 할수 있으며 순회 가능하다. <br>

**그러나 원시타입이므로 불변함**

```js
//인덱스로 접근해 부분 문자값을 변경하려 해도 변경되지 않음

let str = "letter";

str[0] = "g"; // 원시 타입이기 떄문에 불변함. 그치만 에러 발생 하지 않음.
console.log(str); // letter
```

#### 값에 의한 전달

원시 타입의 변수를 다른 변수에 할당 할때, 그 값 자체를 복사해 전달. <br>
그 값은 새로 생성되어 다른 메모리 공간에 저장됨. <br>
데이터 값은 같으나 변수가 가르키는 메모리 주소는 다름. <br>
각 다른 메모리 공간에 저장되어 있는 별개의 값임. <br>

```js
let tomato = "red";
let apple = tomato;

tomato = "green"; // tomato가 재할당 되어도 apple의 값과 관계 없음

console.log(tomato); // green
console.log(apple); // red
```

<br>

변수는 값이 저장되어 있는 공간의 메모리 주소를 기억해 데이터 값에 접근.

## 객체

> 변경 가능한 값 (mutable value)

객체는 원시타입보다 복잡한 자료 구조로 크기를 미리 메모리를 확보하기 어렵고 원시 값처럼 재할당을 통해 새롭게 생성하는 방식은 비용이 많이 드므로 변경 가능한 값으로 설계되어 있다.

**변수는 객체를 참조한다.**

객체의 변수는 그 실 객체 데이터가 저장되어있는 메모리 주소를 참조한 값을 가지고 있다.<br>
변수에 저장되어있는 참조값을 통해 실제 객체에 접근해 재할당없이 참조값으로 객체를 직접 변경 가능하다. <br>
따라서 여러개의 식별자가 하나의 객체를 공유 할 수 있다. <br>

#### 얕은 복사 (Shallow copy)와 깊은 복사 (Deep copy)

얕은 복사는 객체를 1단계까지만 복사를 하고 중첩된 객체는 같은 참조값을 가진다.<br>

- 이 이유도 생각해보면 중첩되지 않은 1단계는 무조건 없거나 값자체를 깊은 복사하는 원시타입이기 때문. <br>

깊은 복사는 중첩되어 있는 객체까지 모두 복사 한다.<br>
복사가 되었다는 의미는 새롭게 생성되 원본가 다른 객체라는 의미.

**자바스트립트에서는 객체는 얕은 복사가 되고 원시타입은 깊은 복사가 된다.**

#### 참조에 의한 전달(공유에 의한 전달)

객체는 참조를 전달 하기 때문에 여러 식별자가 같은 데이터를 공유하게 된다.<br>
객체가 1단계만 복사된다는 말도 그 안의 중첩된 객체는 각자 다른 메모리 공간을 가지며 복사될때 참조값이 전달되기 때문에, 새 변수에 할당을 했더라도 중첩된 객체에 접근해 값을 변경하면 원본 객체의 값이 변경된다. <br>
(전달된 참조값이 원본과 같기 때문에 원본을 바꾸는것과 같음.)
