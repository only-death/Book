# 11. 원시 값과 객체의 비교

:원시 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체 타입, BigInt)과 객체타입을 구분할 수 있다.

- **원시 타입**의 값은 변경 불가능한 값이다. 이에 비해 **객체**는 변경 가능한 값이다.
- **원시 값**을 변수에 할당하면 변수(확보된 메모리 공간)에는 <span style="background-color:#C0FFFF; color:#2D3748">실제 값이 저장</span>된다. 이에 비해 **객체를 변수에 할당**하면 변수(확보된 메모리 공간)에는 <span style="background-color:#C0FFFF; color:#2D3748">참조된 값</span>이 저장된다.
- **원시 값**을 갖는 변수는 다른 변수에 할당하면 원시 값이 복사되어 전달된다. 이를 <span style="background-color:#C0FFFF; color:#2D3748">값에 의한 전달</span>이라 한다. 이에 비해 **객체**는 원본의 참조 값이 복사되어 전달된다. 이를 <span style="background-color:#C0FFFF; color:#2D3748"> 참조에 의한 전달</span>이라고 한다.

## 1. 원시 값

### 1. 변경 불가능한 값

: 원시타입의 값은 읽기 전용 **값**으로 변경할 수 없다. 이러한 특성은 데디이터 신뢰성을 보장한다.

- 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과

- 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름(재할당 가능)
- 상수: 재할당이 금지된 변수

```js
const o = {}; // 상수

o.a = 1; // 원시 값은 변경할 수 없지만 할당한 객체는 변경할 수 있다.
console.log(o); //{ a: 1 }
```

: 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 이러한 특성을 **불변성** 이라고 한다.

### 2. 문자열과 불변성

: 원시 값을 저장하려면 확보해야 하는 메모리 공간의 크기를 결정해야 한다. 문자열은 0개 이상의 문자로 이뤄진 집합을 말하며, 1개의 문자는 2바이트의 메모리 공간에 저장되며, 변경 불가능하다. 숫자값은 1도, 10000도 동일한 8바이트가 필요하다.

</br>
: C 타입에는 하나의 문자를 위한 데이터 타입(char)만 있을 뿐 문자열 타입은 존재하지 않는다. 자바에서는 문자열을 string 객체로 처리한다.

```js
var str = 'hello'; // world로 바뀌어도 메모리에 존재한다
str = 'world'; // 가리키는 데이터가 world 바뀌었다

// 문자열은 유사 배열 객체이면서 *인터러블*므로 배열과 유사하게 문자에 접근할 수 있다.

console.log(str[0]); // w

// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 5
console.log(str.toUpperCase()); // WORLD
```

유사 배열: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. for문으로 순회 가능.

```js
var str = 'hello';

str[0] = 'W'; // 문자열은 원시 값이므로 변경할 수 없고 에러가 발생하지 않는다.

console.log(str); // hello
```

### 3. 값에 의한 전달

```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80

// 값에 의한 전달이기에 원본값이 변경되어도 copy는 변경되지 않는다
// score 변수와 copy 변수의 80은 다른 메모리 공간에 저장된 별개의 값이다.
```

"값에 의한 전달"도 값이 아닌 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

- 메모리 주소가 다르거나 메모리 주소를 같게끔 하는 평가 방식이 가능하다.

중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되거 어느 한 쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

## 2. 객체

: 프로퍼티의 개수가 정해져 있지 않고 동적으로 추가, 삭제할 수 있으며 프로퍼티 값에 제약이 없다. 따라서 객체는 확보해야 원시 값과 같이 확보해야 할 메모리 공간의 크기를 정해둘 수 없다. 객체는 원시값과 다른 방식으로 동작하도록 설계되어 있다.

- <span style="background-color:#C0FFFF; color:#2D3748"> 자바스크립트 객체의 관리 방식</span>

### 1. 변경 가능한 값

: 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다. 객체를 할당한 변수에 재할당하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.(0x0001332의 데이터가 변경된다.)

```js
var person = {
  name: 'Lee',
};

// 프로퍼티 값 갱신, 동적 생성 가능
person.name = 'Kim';

console.log(person); // { name: 'Kim' }
```

이렇게 하는 이유: 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.
</br>
부작용: 여러 개의 식별자가 하나의 객체를 공유할 수 있다.

**얕은 복사와 깊은 복사**
예제 11-14 참고

- 얕은 복사: 객체를 할당한 변수를 다른 변수에 할당하는 것
- 깊은 복사: 원시 값을 할당한 변수를 다른 변수에 할당하는 것

```js
const o = { x: { t: 1 } };

// 얕은 복사
const c1 = { ...o };

console.log(c1); // { x: { t: 1 } }
console.log(o === c1); // false
console.log(o.x === c1.x); // true
```

### 2. 참조에 의한 전달

: 두 개의 식별자가 하나의 객체를 공유한다. 따라서 원본 또는 사본 중 어느 한 쪽에서 객체를 변경(추가, 삭제)하면 서로 영향을 주고받는다.

```js
var person = {
  name: 'Lee',
};

//참조값 복사(얕은 복사), 동일한 참조 값을 갖는다.
var copy = person;

console.log(person === copy); // true

person.age = 10;
copy.address = 'Seoul';

console.log(person); // { name: 'Lee', age: 10, address: 'Seoul' }
console.log(copy); // { name: 'Lee', age: 10, address: 'Seoul' }
```

: "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에서 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만 존재한다고 말할 수 있다.

```js
var person1 = {
  name: 'Lee',
};

var person2 = (person = {
  name: 'Lee',
});

console.log(person1 === person2); // false 객체 리터럴은 평가될 때마다 객체를 생성한다
console.log(person1.name === person2.name); // true person1과 person2는 모두 name이라는 프로퍼티를 갖고 있고, 그 값은 원시 값 'Lee'이다
```
