# 38장. 브라우저의 렌더링 과정

## 네트워크 요청

### 요청과 응답

브라우저가 서버에 HTML, CSS, JS 등 리소스를 요청(Request)하고 서버로부터 응답(Response) 받아 브라우저에 시각적으로 렌더링한다.

서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다.
주소창에 URL을 입력 후 엔터를 누르면 URL 호스트 이름이 DNS를 통해 IP주소로 변환되고 이 IP주소를 갖는 서버에게 요청을 전송한다.
대부분의 웹 서버는 루트 요청('/')에 대해 기본적으로 index.html을 응답하도록 설정되어 있다.

### HTTP 1.1과 HTTP 2.0

> HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다

- **HTTP 1.1**

  - 기본적으로 커넥션당 하나의 요청과 응답만을 처리
  - 파이프라이닝을 통해 여러 요청을 순차적으로 처리할 수 있지만 Head-of-Line Blocking 문제 발생
  - 커넥션당 하나의 요청과 응답만을 처리하기 때문에 리소스 요청이 많은 웹페이지의 로딩이 느려질 수 있음

- **HTTP 2.0**
  - 멀티플렉싱을 통해 하나의 커넥션에서 여러 요청과 응답을 동시에 처리 가능
  - 헤더 압축을 통한 데이터 전송량 감소
  - 서버 푸시 기능으로 클라이언트 요청 없이도 리소스 전송 가능
  - 결과적으로 웹페이지 로딩 속도가 크게 향상됨

## HTML 파싱 및 DOM 트리 생성

브라우저가 HTML 문서를 파싱하여 DOM(Document Object Model) 트리를 생성하는 과정은 다음과 같다:

### 1. 바이트 → 문자

- 서버는 HTML 문서를 바이트로 인터넷을 경유해 전송
- HTTP 헤더나 meta 태그의 `charset` 속성에 명시된 인코딩 방식을 확인
- 브라우저는 바이트를 문자열로 변환한 후 문자열을 렌더링 엔진에 전달

### 2. 문자 → 토큰

- 렌더링 엔진은 전달받은 문자열을 토큰으로 분해(Tokenization)
- 토큰은 문법에 맞는 코드의 최소 단위로, HTML 태그나 속성, 내용 등을 나타냄

예시:

```html
<h1>Hello</h1>
```

다음과 같이 토큰으로 분해된다:

- start tag: `<h1>`
- text: `Hello`
- end tag: `</h1>`

### 3. 토큰 → 노드

- 토큰은 tree constructor로 전달되어 노드 객체로 변환
- 노드는 DOM을 구성하는 기본 요소
  - 요소 노드: HTML 태그를 표현
  - 텍스트 노드: 텍스트 내용을 표현
  - 어트리뷰트 노드: 태그의 속성을 표현
  - 주석 노드: 주석을 표현

예시: `<html>` 토큰 → `HTMLHtmlElement` 노드 객체

### 4. 노드 → DOM 트리

- 트리 생성 단계에서 토큰의 중첩 구조가 DOM 계층에 반영됨
- 부모-자식 관계를 갖는 트리 자료구조로 DOM 트리를 생성
- 문서의 구조화된 표현을 제공하여 프로그래밍 언어가 DOM에 접근할 수 있는 방법을 제공

## CSS 파싱 및 CSSOM 트리 생성

렌더링 엔진은 HTML 파일을 처음부터 한 줄씩 순차적으로 파싱해 DOM을 생성한다.
그러다 CSS를 로드하는 인라인, 내부, 외부 스타일시트를 만나면 렌더링 엔진은 DOM 생성을 중단하고 스타일시트를 파싱해 CSSOM(CSS Object Model)을 생성하기 시작한다.

### CSS 파싱 과정

1. **외부 CSS 파일 로드**:

   - `<link>` href에 지정된 CSS 파일을 서버에 요청
   - 서버로부터 응답 받은 CSS 파일을 렌더링 엔진에 전달

2. **CSS 파싱**:

   - 바이트 → 문자 → 토큰 → 노드 → CSSOM 트리
   - 각 CSS 규칙을 파싱하여 선택자와 선언부로 분리
   - 선택자에 따라 스타일을 적용할 요소를 결정

3. **CSSOM 생성**:
   - CSSOM은 CSS의 계단식(Cascade) 규칙, 상속, 우선순위, 명시도에 따라 각 요소의 최종 스타일을 계산
   - 부모 요소로부터 상속되는 속성 계산
   - 충돌하는 스타일 규칙의 우선순위 결정

## JavaScript 파싱 및 실행

HTML 파일을 파싱 중 `<script>` 태그를 만나면 렌더링 엔진은 자바스크립트 파일을 로드하고 자바스크립트 엔진으로 제어권을 넘긴다.

### JS 엔진의 코드 처리 과정

1. **JavaScript 소스코드 → 토큰**

   - 어휘 분석(Lexical Analysis)을 통해 소스코드를 문법적 의미를 갖는 최소 단위인 토큰으로 분해
   - 예: 변수명, 연산자, 키워드, 구분자 등을 토큰으로 분리

2. **토큰 → AST(Abstract Syntax Tree) 생성**

   - 토큰들의 집합을 구문 분석(Syntax Analysis)하여 추상 구문 트리 생성
   - AST는 소스코드의 구조를 트리 형태로 표현한 자료구조

3. **AST → 바이트코드 생성**

   - AST를 바탕으로 자바스크립트 엔진에서 실행 가능한 중간 코드인 바이트코드 생성
   - V8 엔진: Ignition 인터프리터가 AST를 바이트코드로 변환
   - SpiderMonkey: Baseline 컴파일러가 AST를 바이트코드로 변환

4. **인터프리터 실행 및 최적화**
   - 바이트코드는 JS 엔진의 인터프리터에 의해 즉시 실행
   - 자주 실행되는 코드(Hot code)는 JIT(Just-In-Time) 컴파일러에 의해 머신 코드로 최적화되어 실행
   - V8 엔진: TurboFan이 최적화 담당
   - SpiderMonkey: IonMonkey가 최적화 담당

### `<script>` 태그와 렌더링 블로킹

`<script>` 태그의 위치에 따라 **HTML 파싱이 중단(Blocking)**될 수 있다.

자바스크립트는 DOM이나 CSSOM을 동적으로 변경할 수 있기 때문에,
기본적으로 스크립트가 다운로드 및 실행이 끝날 때까지 HTML 파싱이 중단된다.

#### 렌더링 최적화 방법

| 방법                        | 설명                                                                                                        | 장단점                                                                                                                                         |
| --------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. `<body>` 최하단 배치** | 스크립트를 `<body>` 태그 끝에 두어, DOM 생성 후 실행하도록 함                                               | ✅ DOM이 완전히 구성된 후 실행<br>❌ 스크립트 로딩과 실행이 HTML 파싱 후에 시작되어 전체 로딩 시간이 길어질 수 있음                            |
| **2. `defer` 속성 사용**    | HTML 파싱과 병렬로 스크립트 다운로드, DOM 파싱이 끝난 뒤 실행<br>DOMContentLoaded 이벤트 직전에 실행됨      | ✅ 스크립트 실행 순서 보장<br>✅ 병렬 다운로드로 효율적<br>✅ DOM 완전히 구성 후 실행                                                          |
| **3. `async` 속성 사용**    | HTML 파싱과 병렬로 스크립트 다운로드, JS 파일 로드 즉시 실행<br>실행 시점에 따라 HTML 파싱이 중단될 수 있음 | ✅ 페이지 로딩에 중요하지 않은 독립적인 스크립트에 적합<br>❌ 스크립트 실행 순서 보장되지 않음<br>❌ DOM이 완전히 구성되기 전에 실행될 수 있음 |

## 렌더 트리 생성

DOM 트리와 CSSOM 트리를 결합해 렌더 트리(Render Tree)를 생성한다.

### 렌더 트리의 특징

- 렌더 트리는 화면에 표시되는 요소만 포함
  - `display: none`이 적용된 요소나 `<head>` 등은 포함되지 않음
  - `visibility: hidden`이 적용된 요소는 공간을 차지하므로 포함됨
- 각 노드는 계산된 스타일 정보를 가짐
- 최종적으로 화면에 렌더링할 내용과 스타일 정보를 담고 있음

## 레이아웃 (Reflow)

렌더 트리를 기반으로 각 요소의 정확한 위치와 크기를 계산하는 과정이다.

### 레이아웃 과정의 주요 작업

- 뷰포트 내에서 각 요소의 정확한 위치(x, y 좌표) 계산
- 요소의 크기(width, height)와 여백, 패딩, 테두리 등 계산
- 상대적 위치(relative, absolute, fixed 등)에 따른 위치 조정
- 텍스트와 이미지의 크기 및 위치 계산

레이아웃은 계산 비용이 높은 작업으로, 자주 발생하면 성능에 영향을 미칠 수 있다.

## 페인트 (Paint)

계산된 레이아웃 정보를 바탕으로 화면에 픽셀을 그리는 과정이다.

### 페인트 과정의 주요 작업

- 배경색, 텍스트, 이미지, 테두리, 그림자 등 시각적 요소를 픽셀로 변환
- 레이어별로 페인트 작업 수행
- z-index 속성에 따라 요소의 쌓임 순서 결정
- 투명도(opacity) 및 블렌딩 모드 적용

## 컴포지팅 (Compositing)

여러 레이어를 하나로 합성하여 최종 화면을 만드는 과정이다.

### 컴포지팅의 주요 특징

- GPU 가속을 통한 효율적인 레이어 합성
- transform, opacity와 같은 속성은 레이아웃 단계를 건너뛰고 컴포지팅만 수행 가능
- 애니메이션이나 전환 효과의 성능 최적화에 중요
- will-change 속성을 통해 특정 요소를 별도 레이어로 승격시켜 성능 향상 가능

## 전체 렌더링 과정 요약

1. **HTML 파싱** → DOM 트리 생성
2. **CSS 파싱** → CSSOM 트리 생성
3. **JavaScript 실행** → DOM, CSSOM 조작 가능
4. **DOM + CSSOM** → 렌더 트리 생성
5. **레이아웃**(Reflow) → 요소 위치와 크기 계산
6. **페인트**(Paint) → 픽셀 그리기
7. **컴포지팅**(Compositing) → 레이어 합성

이 과정은 사용자 상호작용, JavaScript 코드 실행, 또는 네트워크로부터 새로운 데이터를 받아올 때마다 전체 또는 일부가 반복될 수 있다.
