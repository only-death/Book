# 14. 전역 변수의 문제점

## 1. 변수의 생명 주기

### 1. 지역 변수의 생명 주기

: 함수의 생명 주기와 같다

```js
var x = 'ss';

function foo() {
  // 힘수 생성
  console.log(x); //undefined 값 할당
  var x = 'zz';
  // 변수 x 소멸
}

foo();
console.log(x); // ss
```

: 변수의 생명 주기는 메모리 공간 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 변환되는 시점까지다.

</br>
: 호이스팅은 스코프를 단위로 동작한다.

### 2. 전역 변수의 생명 주기

:함수와 달리 전역 코드는 호출 없이 실행된다. 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.

```js
// 전역 변수 x 생성
// 전역 변수 x에 값 할당
var x = 'ss'; // 전역 객체 프로퍼티(전역 변수의 생명주기 = 전역 객체의 생명주기)

function foo() {
  console.log(x);
  var x = 'zz';
}

foo();
console.log(x);
```

## 2. 전역 변수의 문제점

- 암묵적 결합: 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이므로 모든 코드가 전역 변수를 참조, 변경 가능
- 긴 생명 주기
- 스코프 체인 상에서 종점에 존재: 변수를 검색할 때 전역 변수가 가장 마지막에 검색되어 **전역 변수의 검색 속도가 가장 느림**
- 네이스페이스 오염: 파일이 분리되어 있다고 해도 하나의 전역 스포크를 공유하므로 다른 파일 내에 동일한 이름으로 명명된 전역 변수, 함수가 같은 스코프 내에 존재하면 예상치 못한 결과를 불러 일으킴

## 3. 전역 변수의 사용을 억제하는 방법

- 번역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다. 변수의 스코프는 좁을수록 좋다.

### 1. 즉시 실행 함수

### 2. 네임스페이스 객체

: 식별자 충돌에는 효과가 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그자지 유용하진 않다.

```js
var MYAPP = {};

MYAPP.name = 'Lee';

console.log(MYAPP.name); // Lee
```

### 3. 모듈 패턴

: 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 클로저를 기반으로 동작하며, 정보 은닉을 구현하기 위해 사용한다.

### 4. ES6 모듈

: 독자적인 모듈 스코프를 제공한다.

```js
<script type='module' src='lib.mjs'></script>
<script type='module' src='app.mjs'></script>
```

: 확장자는 mjs를 권장한다.

# 15. let, const 키워드와 블록 레벨 스코프

## 1. var 키워드로 선언한 변수의 문제점

1. 변수 중복 선언 허용: 변수를 중복 선언하면서 값까지 할당하면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생한다.
2. 함수 레벨 스포트: 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

```js
var x = 1; // 힘수만을 지역 스코프로 인정

if (true) {
  // for 문도 마찬가지다.
  var x = 10;
}

console.log(x); // 10
```

3. 변수 호이스팅

## 2. let 키워드

1. 중복 선언 금지: 문법 에러 발생한다.
2. 블록 레벨 스코프: 전역에서 선언된 변수와 코드 블록 내에서 선언된 변수는 다른 별개의 값이다.

```js
let i = 10; // 전역 스코프

function foo() {
  // 힘수레벨 스코프
  let i = 100;
  for (let i = 1; i < 3; i++) {
    // 블록레벨 스코프
    console.log(i); // 1 2
  }
  console.log(i); // 100
}

foo();
console.log(i); // 10
```

3. 변수 호이스팅: 변수 호이스팅이 발생하지 않는 것처럼 동작한다. "선언 단계"와 "초기화 단계"가 분리되어 진행돼 참조 에러가 발생한다.

4. 전역 객체와 let

- var = 전역 객체(window)의 프로퍼티가 된다.
- let = 전역 객체의 프로퍼티가 아니다.

```js
// window: 브라우저에서만 존재

var x = 1;

y = 2;

console.log(window.x); // 1
console.log(y); // 2

let j = 1;

console.log(global.j); // undefined
```

## 3. const 키워드

1. 선언과 초기화: 선언과 동시에 초기화된다.
2. 재할당 금지
3. 상수: 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
4. const 키워드와 객체: const 키워드로 선언된 변수에 객체를 할당할 경우 값을 변경할 수 있다.

```js
const person = {
  name: 'Lee',
};

person.name = 'Kim';

console.log(person); // { name: 'Kim' }
```

## 4. var vs let vs const

- 기본적으로 **const**를 선언하고 재할당이 필요한 경우 **let**을 사용하는 것이 좋다.
