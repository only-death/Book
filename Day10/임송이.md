# 14장 전역 변수의 문제점

### 변수의 생명주기

`생명주기 `= **메모리 공간의 확보되는 시점 (allocate)**부터 ~ **메모리 공간이 해제(release) 되어 가용 메모리 풀(memory pool)에 반환되는 시점**까지.

`전역 변수`의 생명 주기 = 어플리케이션의 생명 주기 <br>
`지역 변수`의 생명 주기 = 대부분 함수 내부에 선언된 지역변수는 함수 생명 주기와 일치.

**변수는 자신이 등록된 스코프가 소멸(메모리 해제) 때 까지 유효하다.**

_다른 코드에서 함수내 지역 변수를 참조한다면 함수보다 그 변수가 더 오래 생존 할 수 도 있음 (스코프를 참조하고 있으면 스코프가 소멸되지 않기 때문에)_

호이스팅은 스코프 단위로 동작한다.

### 전역 변수의 생명 주기

`전역 객체(global object)`: 자바스크립트 엔진에 의해 어떤 객체 보다도 먼저 생성성되는 특수한 객체.

- 표준 빌트인 객체와 호스트 객체, `var`키워드로 선언한 전역변수와 전역 함수를 프로퍼티로 가짐.
- 클라이언트 사이드 환경(브라우저) = `window`가 전역 객체
- 서버 사이드 환경(Node.js) = `global`이 전역 객체<br>
  (환경에 따라 전역 객체를 가리키는 다양한 식별자가 있었지만 ES11에서는 globalThis로 통일됨.)

### 전역 변수의 문제점

- 암묵적 결합 (implicit coupling) 허용. (전역 변수는 어디서든 참조 결합 할 수 있다/ 유효범위가 커짐)
- 긴 생명주기 (메모리 사용)
- 스코프 체인상 종점에 존재 (전연변수 검색속도가 가장 느림)
- 네임 스페이스 오염 (파일이 분리되어있어도 하나의 전역 스코프 공유)

### 전역 변수 사용 억제 방법

- IIFE(즉시 실행 함수) 사용<br>
  모든 코드를 IIFE로 감싸 모든 변수를 지역 변수화. (전역 변수 생성은 안하게 됨)
- namespace 객체<br>
  전역에 namespace 역할을 담당할 객체 생성
  전역변수 처럼 사용할 변수를 객체에 프로퍼티로 추가
- 모듈 패턴<br>
  관련있는 변수와 함수를 묶어 IIFE로 감싸 모듈화 하는것. 이것의 장점은 코드를 캡슐화해 정보 은닉을 할 수 있다는 것이다. <br>
  `캡슐화(capsulation)`: 객체 상태 프로퍼티와 매서드를 하나로 묶어 사용

- ES6 모듈<br>
  파일 자체의 도자적인 모듈 스코프를 제공해 모듈내 `var`로 선언한 변수는 전역 변수가 되지않는다.

  <br>

# 15장: let, const 키워드와 블록 레벨 스코프

### `var` 키워드

#### 변수 중복 선언 가능

- 선언단계와 초기화 단계가 동시에 이루어짐. 런타임 전에 선언되고 undefined로 초기값이 됨.
- 중복 선언시 초기화문의 유무로 다르게 동작됨. (초기화문이란 초기값을 할당하는것.)

```js
var a = 1;
var b = 1;

// 중복선언시 초기화문을 써도 var키워드가 없는듯이 동작.
var a = 10; // a = 10과 같음. 재할당되버림

var b; // 중복선언시 초기화문이 아닌 이 변수 선언문은 무시됨.

console.log(a); // 10
console.log(b); // 1
```

#### 함수 레벨 스코프

`var`키워드로 선언한 변수는 함수레벨 스코프만 지역 변수로 인정하기 때문에 블록 레벨에서는 전역 변수로 됨.

#### 변수 호이스팅

`var` 키워드로 선언한 변수는 호이스팅되어 실행전 선언과 초기화가 동시에 돼 undefined를 가짐.<br>
선 호출이 되어도 에러를 잡지않는 문제가 있음.

### `let`, `const` 키워드

`let`과 `const`는 `var`와 다르게 전역 스코프에서 선언 되어도 전역객체 프로퍼티로 등록되지 않음.

#### 변수 중복 선언 ❌

`let`과 `const` 키워드로 선언된 변수는 중복 선언시 SyntaxError를 발생시킴.

#### 블록레벨 스코프

`let`과 `const` 키워드로 선언한 변수는 모든 코드블록( 함수 포함) {} 레벨 스코프를 따름.

#### 변수 호이스팅

`let`과 `const` 키워드로 선언한 변수는 호이스팅이 되지 않는것처럼 동작함.<br>
선언전에 참조하면 ReferenceError(참조에러)를 발생시킴.

`var` 키워드로 선언된 변수는 '선언' 과 '초기화'가 동시에 진행되지만, `let`과 `const`롤 선언된 변수는 2단계가 따로 분리되어 자바스크립트엔지인 런타임전에 선언단계를 실행시키지만, 초기화 단계는 변수선언문에 도달했을때 진행됨.

```js
//런타임 전에 선언단계 실행 (스코프에 변수 존재 등록)
console.log(apple); // ReferenceError: apple is not defined

let apple; // 변수 선언문에서 초기화 단계 실행
console.log(apple); // undefined

apple = 1; // 값 할당.

console.log(apple); // 1
```

스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할수 없는 구간을 `일시적 사각지대(Temporal Dead Zone: TDZ`라 부른다.

호이스팅(끌어오림)이 되지 않는것처럼 보이지만 선언단계가 먼저 실행되니 호이스팅이 되긴함.

```js
let num = 1; // 전역 변수

{
  console.log(num); // ReferenceError: cannot access 'foo' before initialization
  let num = 2; // 지역변수
}
```

호이스팅이 되지않으면 블록문 안 콘솔은 전역변수인 1을 참조하면 그만인데 블록 스코프가 생성되고 그 지역변수인 num이 호이스팅돼 선언단계까지 진행이 되어 참조 오류가 뜸.

### `let` 과 또 다른 `const` 키워드 특징

#### const 키워드는 선언과 동시에 초기화문을 써줘야함.

값을 초기화 해줘야됨.
`const num = 1;` 👌
`const num;`❌ // SyntaxError: Missing initailizer in const declaration

#### 재할당 금지

`const`로 선언된 변수는 재할당이 되지않음 (TypeError: Assignment to constant variable)

#### 상수

재할당이 허용 되지 않기 때문에 immutable value인 원시값은 한번 선언되면 할당할 수 없기 떄문에 상수를 사용할때 많이 사용함

```js
// 상수는 screaming snake case로 표기
const TAX_RATE = 0.1;
```

#### 객체

객체는 mutable value이기 떄문에 재할당은 못하더라도 객체의 프로퍼티에 접근에 값을 변경할 수 있음.

```JS
const obj = { key: "value" };

obj.key = "new value"; // 값 변경 가능

console.log(obj); // { key: 'new value' }
```

### let과 const의 차이 정리

| 특징             | let       | const     |
| ---------------- | --------- | --------- |
| 재할당 가능 여부 | 가능      | 불가능    |
| 선언 후 초기화   | 선택 사항 | 필수      |
| 스코프           | 블록 레벨 | 블록 레벨 |

### 권장 사항

- `var` 대신 `let`/`const` 사용: var의 호이스팅 문제와 함수 레벨 스코프 제한을 해결.
- 불변 데이터에는 `const` 사용: 의도를 명확히 하여 유지보수성을 높임.
- 모던 자바스크립트 코드 스타일: `let`/`const`를 통해 안전하고 직관적인 코드 작성.
