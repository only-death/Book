# 14장 전역 변수의 문제점

전역 변수의 무분별한 사용은 위험하다.  
**전역 변수를 사용할 이유가 없으면 지역변수를 사용하는 것이 좋다!**

## 변수의 생명 주기

### 지역 변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 갖고 언젠가는 소멸되는 **생명 주기**가 있다. 변수에 생명 주기가 없다면 한 번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 됨.

하지만 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸함  
👉 즉, **지역 변수의 생명주기는 함수의 생명 주기와 일치함**

![](https://velog.velcdn.com/images/pmj9498/post/fb7031f6-9bee-42cb-9f10-2e9330bf3816/image.png)

![](https://velog.velcdn.com/images/pmj9498/post/847f17dc-47f0-4486-a5e2-b152edf1fe13/image.png)

지역 변수 x는 ① 의 시점에 이미 선언되었고 `undefined`로 초기화 되어 있음  
지역 변수는 함수 전체에서 유효하지만 변수 할당문이 실행되기 이전까지는 `undefined` 값을 갖는다.

**호이스팅은 스코프를 단위로 동작함**  
전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두로 끌어 올려진 것처럼 동작하고,  
지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작함

즉, 호이스팅은 변수 선언이 **스코프의 선두**로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

### 전역 변수의 생명 주기

`var` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨 이는 전역 변수의 생명 주기가 전역 객체의 생명주기와 일치한다는 것을 말함

> 전역 객체(global object)
>
> 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체  
> 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 `window`,  
> 서버 사이드 환경(Node.js)에서는 `global` 객체를 의미함
>
> 전역 객체는 표준 빌트인 객체(`Object`, `String`, `Number`, `Function`, `Array` ...)와 환경에 따른 호스트 객체 (클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 `var` 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

브라우저 환경에서 전역 객체는 `window`이므로 브라우저 환경에서 `var` 키워드로 선언한 전역 변수는 전역 객체 `window`의 프로퍼티(웹페이지 닫기 전까진 유효함)  
👉 **`var` 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치함**

![](https://velog.velcdn.com/images/pmj9498/post/f8b326dc-7df8-4e8e-b5f6-fdc0fd305e0c/image.png)

## 전역 변수의 문제점

- **암묵적 결합**
  - 전역 변수를 선언한 의도는 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것임
  - 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합**을 허용하는 것임
  - 변수의 유효 범위가 클수록 코드의 가독성은 나빠지고 의도치 않은 상태 변경 위험성도 높아짐
- **긴 생명 주기**
  - **전역 변수는 생명 주기가 길다.** 그래서 메모리 리소스도 오랜 기간 소비함
  - 지역 변수는 전역 변수보다 생명 주기가 훨씬 짧음. 그래서 전역 변수보다 상태 변경에 의한 오류 발생 확률이 낮고 메모리 리소스도 짧은 기간만 소비함
- **스코프 체인 상에서 종점에 존재**
  - 전역 변수는 스코프 체인 상에서 종점에 존재함(지역 -> 전역(상위 스코프)으로 검색하기 때문임)
  - 가장 마지막에 검색된다는 것을 말하며 이는 전역 변수의 검색 속도가 가장 느림을 알 수 있음
- **네임스페이스 오염**
  - 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 야기할 수 있음

## 전역 변수의 사용을 억제하는 방법

🔥 **전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야함(변수의 스코프는 좁을수록 좋다!)**

✨ 전역 변수의 사용을 억제할 수 있는 방법

### 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨

![](https://velog.velcdn.com/images/pmj9498/post/51c136df-59df-4e20-93a7-508bd3e72ca3/image.png)

이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용됨.

### 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 프로퍼티를 추가하는 방법  
계층적으로 구성할 수도 있음

![](https://velog.velcdn.com/images/pmj9498/post/bd20fa32-38cc-445d-824a-9c681b2ebd9b/image.png)

💢그다지 유용하진 않음

### 모듈 패턴

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 **즉시 실행 함수**로 감싸 하나의 모듈을 만듦  
🔥 모듈 패턴의 특징은 전역 변수의 억제는 물론 **캡슐화**까지 구현할 수 있다는 것

> 캡슐화
>
> 객체의 상태를 나타내는 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것  
> 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 **정보 은닉**이라 함
>
> 대부분의 객체지향 프로그래밍 언어는 클래스를 구성하는 멤버에 대해 public, private, protected 등의 접근 제한자를 사용해 공개 범위를 한정할 수 있다. 이를 통해 클래스 외부에 제한된 접근 권한을 제공하며 내부를 보호하는 기능을 제공함
>
> 하지만 자바스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않음

모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용하기도 한다.

![](https://velog.velcdn.com/images/pmj9498/post/a7cb92ba-32a3-435d-bddd-de6a038bab0a/image.png)  
![](https://velog.velcdn.com/images/pmj9498/post/1a849c86-b638-4081-8440-e99359f6aa66/image.png)

### ES6 모듈

ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없음

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공함(`var` 키워드로 선언한 변수는 전역 변수가 아니며 `window` 객체의 프로퍼티도 아님)

> 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서는 ES6 모듈을 사용할 수 있음  
> `script` 태그에 `type="module"` 어튜리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작함  
> 모듈의 파일 확장자는 `mjs`를 권장함
>
> ![](https://velog.velcdn.com/images/pmj9498/post/722e8ab0-8dfd-4d69-8fbb-575307c445dd/image.png)

# 15장 let, const 키워드와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

### 변수 중복 선언 허용

초기화문(변수 선언과 동시에 초기값을 할당하는 문)이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됨(이때 에러 발생 ❌)

### 함수 레벨 스코프

`var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정함(함수 외부에서는 모두 전역 변수, 심지어 코드 블록 내에서도)

![](https://velog.velcdn.com/images/pmj9498/post/4334fd43-ff53-4e3c-bc4f-4ff31ddf9696/image.png)  
![](https://velog.velcdn.com/images/pmj9498/post/16dfedd9-ef09-42a3-ae0b-91d6e87edc2e/image.png)

### 변수 호이스팅

![](https://velog.velcdn.com/images/pmj9498/post/8f0fe796-dfa4-4120-a524-5c09c1b225a3/image.png)

변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않으며 가독성을 떨어뜨리고 오류를 발생시킬 수 있다.

## let 키워드

`var` 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 `let`과 `const`를 도입함

### 변수 중복 선언 금지

let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생함

![](https://velog.velcdn.com/images/pmj9498/post/e90591b8-2323-4313-9666-f8936874d74e/image.png)  
![](https://velog.velcdn.com/images/pmj9498/post/5464cb0a-7771-49e6-8790-70e45d7ea456/image.png)

### 블록 레벨 스코프

함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따르는 `var` 키워드와 달리 `let` 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, while 문, try/catch 문 등)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따름

![](https://velog.velcdn.com/images/pmj9498/post/94b76e1e-a3e2-4195-963f-28c2c9e52232/image.png)

![](https://velog.velcdn.com/images/pmj9498/post/653387aa-000c-4ff4-85f1-cec777930848/image.png)

### 변수 호이스팅

`var` 키워드로 선언한 변수와 달리 `let` 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 동작함

`var` 키워드로 선언한 변수는 런타임 이전 자바스크립트 엔진에 의해 암묵적으로 "선언 단계"와 "초기화 단계"가 한 번에 진행된다.

![](https://velog.velcdn.com/images/pmj9498/post/65fa3bc5-8923-42fb-bb4f-67d8c91ef35b/image.png)

![](https://velog.velcdn.com/images/pmj9498/post/19e7ebf3-af37-4d06-904e-04798d24530d/image.png)

하지만 `let` 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행됨  
런타임 이전 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되긴 하지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.

`let` 키워드로 선언한 변수는 스코프의 시작 지점 부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다.

> 🔥🔥**일시적 사각지대(Temporal Dead Zone: TDZ)** : 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

![](https://velog.velcdn.com/images/pmj9498/post/16cfa9a2-d4a7-4beb-8057-a0823abaac4f/image.png)

![](https://velog.velcdn.com/images/pmj9498/post/07fa346b-9ee2-4608-a9a7-47ae8a8eddab/image.png)

![](https://velog.velcdn.com/images/pmj9498/post/f1021a9a-ccd3-4da1-a108-980c2bd5c0bc/image.png)

그리고 `let` 키워드로 선언한 변수의 경우 변수 호이스팅이 발생하지 않는다면 전역 변수 foo의 값을 출력해야 하지만 `let` 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조에러가 발생하는 것임

### 전역 객체와 let

`var` 키워드로 선언한 변수는 전역 객체(`window`)의 프로퍼티지만, `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아님  
`let` 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 됨

![](https://velog.velcdn.com/images/pmj9498/post/cee041a6-e67c-44c2-8d48-96d8f887b014/image.png)

## const 키워드

`const` 키워드는 상수(constant)를 선언하기 위해 사용  
`const` 키워드의 특징은 `let` 키워드와 대부분 동일하지만 `let`과 다른 점을 알아보자

### 선언과 초기화

**`const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 함**

```js
const foo = 1;
```

```js
const foo: // SyntaxError: Missing initializer in const declaration
```

그리고 `let` 키워드로 선언한 변수와 마찬가지로 **블록 레벨 스코프**를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작함

![](https://velog.velcdn.com/images/pmj9498/post/38f3c013-74e1-4700-b947-c97dc1cc6b31/image.png)

### 재할당 금지

`var` 또는 `let` 키워드로 선언한 변수는 재할당이 자유로우나 **`const` 키워드로 선언한 변수는 재할당이 금지됨**

![](https://velog.velcdn.com/images/pmj9498/post/35d01977-b6c1-4b7f-b52d-db8ccd82a67b/image.png)

### 상수

**상수**란 재할당이 금지된 변수를 일컫는 말

**`const` 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고, `const` 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.**

일반적으로 상수의 이름은 **대문자로 선언**해 상수임을 명확히 나타냄  
여러 단어로 이뤄진 경우에는 **언더스코어(\_)**로 구분해서 **스네이크 케이스**로 표현하는 것이 일반적임

![](https://velog.velcdn.com/images/pmj9498/post/82620ab2-a24a-4be4-abf3-e53b4ef4650b/image.png)

### const 키워드와 객체

`const` 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없지만 **`const` 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.** 왜냐하면 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.

`const` 키워드는 재할당을 금지할 뿐 "불변"을 의미하지는 않는다. 즉, **새로운 값을 재할당하는 것은 불가능하지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능함**

## 🔥 `var` vs `let` vs `const`

변수 선언에는 기본적으로 `const`를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋음  
`const` 키워드를 사용하면 의도치 않은 재할당을 방지할 수 있어 좀 더 안전함

권장 사용 방법

- ES6를 사용한다면 `var` 키워드는 사용하지 말자
- 재할당이 필요한 경우에 한정해 `let` 키워드를 사용(이때 변수의 스코프는 최대한 좁게 만들기)
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 `const` 키워드를 사용하자

### 결론

⚡ 변수를 선언할 때는 일단 `const` 키워드를 사용하고 반드시 재할당이 필요하다면 그때 `const` 키워드를 `let` 키워드로 변경해도 늦지 않다❗

:memo: [mjd] 14전역변수의문제점15let,const키워드와블록레벨스코프/ -/ 218p
