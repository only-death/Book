# 14. 전역 변수의 문제점
## 14.1 변수의 생명 주기
### 14.1.1 지역 변수의 생명 주기
- 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다.
- 변수는 생물과 유사하게 생성되고 소멸되는 생명 주기가 있다.
- 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.
- 변수는 자신이 선언된 위치에서 생성되고 소멸한다.
- 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다.
- 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.

```
function foo() {
    // 변수 x의 생명 주기
    // 변수 x 생성
    var x = 'local';
    console.log(x);
    // 변수 x 소멸
    return x;
}

foo();
console.log(x);
```

=> 변수의 생명 주기는 메모리의 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지다.


### 14.1.2 전역 변수의 생명 주기
- 함수와 달리 전역 코드는 명시적인 호출 없이 실행된다.
- 전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.
- 함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료한다.
- 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.
- `var` 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

```
// 전역 변수 x의 생명 주기
// 전역 변수 x 생성
var x = 'global';

function foo() {
    console.log(x);
    // 지역 변수 x 소멸
    return x;
}

foo();
console.log(x);
```

## 14.2 전역 변수의 문제점
- 암묵적 결합
  - 전역 변수는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용
  - 유효 범위가 클수록 코드의 가독성은 나빠지고 의도치 않고 상태가 변경될 수 있는 위험성이 높아진다.
- 긴 생명 주기
  - 메모리 리소스도 오랜 기간 소비한다.
  - 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많다.
  - 생명주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다. => 의도치 않은 재할당 가능성
- 스코프 체인 상에서 종점에 존재
  - 전역 변수의 검색 속도가 가장 느리다.
- 네임스페이스 오염
  - ㅎ파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것

## 14.3 전역 변수의 사용을 억제하는 방법
- 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다. (무분별한 전역 변수의 남발은 자제)
- 변수의 스코프는 좁을수록 좋다.

### 14.3.1 즉시 실행 함수
- 함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출된다.
- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

### 14.3.2 네임스페이스 객체
- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.
- 네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가해서 네임스페이스를 계층적으로 구성할 수도 있다.

### 14.3.3 모듈 패턴
- 모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
- 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다.
- 전역 변수의 억젠느 물론 캡슐화까지 구현할 수 있다.

### 14.3.4 ES6 모듈
- ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다.
- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
- 모듈 내에서 `var` 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

# 15. let, const 키워드와 블록 레벨 스코프
## 15.1 var 키워드로 선언한 변수의 문제점
### 15.1.1 변수 중복 선언 허용
- `var` 키워드로 선언한 변수는 중복 선언이 가능하다.

### 15.1.2 함수 레벨 스코프
- `var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. <br>
=> 함수 외부에서 `var`  키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

### 15.1.3 변수 호이스팅
- `var` 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.
- 변수 호이스팅에 의해 `var` 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.
- 단, 할당문 이전에 변수를 참조하면 언제나 `undefined` 를 반환한다.

## 15.2 let 키워드
### 15.2.1 변수 중복 선언 금지
- `var` 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러가 발생하지 않는다.
- 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 재할당되어 변경되는 부작용이 발생한다.
- `let` 키워드로 이름이 같은 변수를 중복 선언하면 **문법 에러** 가 발생한다.

### 15.2.2 블록 레벨 스코프
- `var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프에 따른다.
- `let` 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```
// 전역 스코프
let i = 10;
// 함수 레벨 스코프
function foo() {
    let i = 100;
    // 블록 레벨 스코프
    for (let i = 1; i < 3; i++) {
        console.log(i);
    }
    console.log(i);
}
foo();

console.log(i);
```

### 15.2.3 변수 호이스팅
- `var` 키워드로 선언한 변수와 달리 `let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는다.
- `var`
  - 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 "선언 단계"와 "초기화 단계"가 한번에 진행된다.
  - 변수 선언문 이전에 변수에 접근해도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않고 `undefined` 를 반환
- `let`
  - "선언 단계" 와 "초기화 단계"가 분리되어 진행된다.
  - 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 "선언 단계"가 먼저 실행되지만 "초기화 단계"는 변수 선언문에 도달했을 때 실행된다.
  - 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 **참조 에러**가 발생한다.
  - **일시적 사각지대** : 스코프의 시작 지점부터 초기화 시작 지점까지의 변수를 참조할 수 없는 구간

### 15.2.4 전역 객체와 let
- `var` 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 된다.
- 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

## 15.3 const 키워드
- `const`  키워드는 상수를 선언하기 위해 사용한다. (반드시는 아님)

### 15.3.1 선언과 초기화
- `const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다. <br>
```const foo = 1;```
- `const`  키워드로 선언한 변수는 `let` 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

### 15.3.2 재할당 금지
- `var` , `let` 키워드로 선언한 변수는 재할당이 자유로우나 `const` 키워드로 선언한 변수는 재할당이 금지된다.

### 15.3.3 상수
- `const`  키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
- 원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 있는 방법이 없다.
- 재할당이 금지된 변수

### 15.3.4 const 키워드와 객체
- `const` 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없다.
- 하지만 `const` 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 없다. (원시 값 X, 객체 O)

```js
const person = {
    name: 'Lee';
} ;

// 객체는 변경 가능한 값이다. 따라서 재할당 없이 변경이 가능하다.
person.name = 'Kim';

console.log(person); // {name: "Kim"}
```

## 15.4 var vs. let vs. const
- 변수 선언에는 기본적으로 `const` 를 사용하고 `let` 은 재할당이 필요한 경우에 한정해 사용하는 것이 가능하다.
- `const`  키워드를 사용하면 의도치 않은 재할당을 방지하기 때문에 좀 더 안전하다.
- 안전 사용법
  - ES6을 사용한다면 `var` 키워드는 사용하지 않는다.
  - 재할당이 필요한 경우에 한정해 `let` 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
  - 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 `const` 키워드를 사용한다.

